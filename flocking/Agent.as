package {	import flash.display.*;	import flash.events.Event;	import flash.geom.Vector3D;	import flash.display.DisplayObject;	import flash.geom.Vector3D;	public class Agent extends MovieClip {		public static const ZERO:Vector3D = new Vector3D(0,0,0);		public static const SEPARATION_DISTANCE:Number = 100.0;		//————Member Data ————————		public var maxForce:Number;		public var maxSpeed:Number;		public var maxForceSQ:Number;		public var maxSpeedSQ:Number;		public var velocity:Vector3D;		public var position:Vector3D;		public var oldPosition:Vector3D;		public var acceleration:Vector3D;		public var separationForce:Vector3D;		public var edgeBehavior:String;		public var boundsRadius:Number;		public var boundsCentre : Vector3D = new Vector3D();		private var radius:Number = 10.0;		public var wanderDistance:Number = 60.0;		public var wanderStep:Number = 0.25;		//CONSTRUCTOR : INITIALIZES 3D VECTORS		public function Agent( ) {			velocity = new Vector3D();			position = new Vector3D(300.0, 300.0, 0.0);			oldPosition = new Vector3D();			acceleration = new Vector3D();			separationForce = new Vector3D();		}		public function updateAgentPosition():void {			//TASK 1: SET AGENT'S LAST POSITION			oldPosition.x = position.x;			oldPosition.y = position.y;			oldPosition.z = position.z;			//TASK 2: UPDATE THE VELOCITY BY ADDING ACCELERATION			velocity.incrementBy(acceleration);			if (velocity.lengthSquared > maxSpeedSQ) {				velocity.normalize();				velocity.scaleBy(maxSpeed);			}			position.incrementBy(velocity);			acceleration.x = 0;			acceleration.y = 0;			acceleration.z = 0;		}		/**		* Align the Agent 		* Agents are steered towards a specified target  		* in an easing motion. 		*/		public function alignTo( target : Vector3D, easeDistance : Number, multiplier : Number ):void {			separationForce = steer(target,true,easeDistance);			separationForce.scaleBy(multiplier);			acceleration.incrementBy(separationForce);		}		/**		 * Maintain separation between Agents.		 * If an Agent is within a certain distance of another Agent, 		 * a panicDistance, the Agent will steer to avoid contact.		 */		public function separation( target: Vector3D, panicDistance : Number = 100, multiplier: Number = 1.0 ):void {			//TASK 1: COMPUTE THE DISTANCE BETWEEN AGENT'S POSITION AND THE TARGET			var distance:Number = Vector3D.distance(position,target);			//TASK 2: IF DISTANCE IS IN SEPARATION RANGE (LESS THAN PANIC DISTANCE)			if ( distance <= panicDistance ) {				separationForce = steer(target,true, -  panicDistance);					separationForce.scaleBy(multiplier);				separationForce.negate();				acceleration.incrementBy(separationForce);			}		}		private function steer( target : Vector3D, ease : Boolean = false, easeDistance : Number = 100 ):Vector3D {			separationForce = target.clone();			separationForce.decrementBy(position);			var distance:Number = separationForce.normalize();			if ( distance > 0.00001 ) {				if ( distance < easeDistance && ease ) {					separationForce.scaleBy(maxSpeed * ( distance / easeDistance ));				}				else {					separationForce.scaleBy(maxSpeed);				}				separationForce.decrementBy(velocity);				if (separationForce.lengthSquared > maxForceSQ) {					separationForce.normalize();					separationForce.scaleBy(maxForce);				}			}			return separationForce;		}		public function kinematicWander():void {						//AGENTS WANDER IN A CIRCLE			var circleCenter:Vector3D = velocity.clone();			circleCenter.normalize();			var circleDistance:Number = 1000; 			circleCenter.scaleBy(circleDistance);						//COMPUTE THE DISTANCE TO THE TARGET			var target : Vector3D = new Vector3D(0, -1);			var len:Number = target.length;			var circleRadius:Number = 1500;			target.scaleBy(circleRadius);						// ALTER THE WANDER VECTOR DIRECTION			var wanderAngle:Number = 100;			target.x = 3*len * Math.cos(wanderAngle);			target.y = 3*len * Math.sin(wanderAngle);						// CALCULATE THE SEPARATION FORCE			separationForce = steer(circleCenter.add(target));			acceleration.incrementBy(separationForce);						// CALCULATE THE DISPLACEMENT FORCE			var displacement:Vector3D = new Vector3D(0,-1);			circleRadius = 1500;   //500			displacement.scaleBy(circleRadius);						// ALTER THE VECTOR DIRECTION  - CHANGE THE CURRENT ANGLE			setAngle(displacement, wanderAngle);						// ALTER THE ANGLE IN WHICH THE AGENT WANDERS			wanderAngle +=  Math.random() * 100 -  50;						// CALCULATE THE WANDER FORCE			var wanderForce:Vector3D = circleCenter.add(displacement);			acceleration.incrementBy(wanderForce);		}		public function setAngle(vector :Vector3D, value:Number):void {			var len:Number = vector.length;			vector.x = Math.cos(value) * len;			vector.y = Math.sin(value) * len;		}	}}